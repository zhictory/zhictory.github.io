I"_<p>防抖是 debounce，节流是 throttle。</p>

<p>throttle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。</p>

<p>两者都是在规定时间内多次触发只触发一次，但区别是防抖多次触发会重新计算时间，而节流是按周期触发。</p>

<p>点击这里体验一下：<a href="/demos/funny/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/">防抖和节流</a></p>

<p>防抖的简单实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">method</span><span class="p">.</span><span class="nx">tId</span><span class="p">);</span>
  <span class="nx">method</span><span class="p">.</span><span class="nx">tId</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>节流的简单实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">remain</span> <span class="o">=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">method</span><span class="p">.</span><span class="nx">previous</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">method</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
    <span class="nx">method</span><span class="p">.</span><span class="nx">previous</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>场景：</p>

<ul>
  <li>游戏射击，keydown 事件</li>
  <li>文本输入、自动完成，keyup 事件</li>
  <li>鼠标移动，mousemove 事件</li>
  <li>DOM 元素动态定位，window 对象的 resize 和 scroll 事件</li>
</ul>

<p>参考：</p>
<blockquote>
  <p><a href="https://github.com/hanzichi/underscore-analysis/issues/22">underscore 函数节流的实现</a><br />
<a href="https://github.com/lessfish/underscore-analysis/issues/21">underscore 函数去抖的实现</a></p>
</blockquote>
:ET