I"u<p>BEM 是一种 CSS 的命名方法，解决了模块化命名的问题，它一般由块（block）、元素（element）、修饰符（modifier）组成。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.block</span> <span class="p">{}</span> <span class="c">/* 代表了更高级别的抽象或组件 */</span>
<span class="nc">.block__element</span> <span class="p">{}</span> <span class="c">/* 代表 .block 的后代，用于形成一个完整的 .block 的整体 */</span>
<span class="nc">.block--modifier</span> <span class="p">{}</span> <span class="c">/* 代表 .block 的不同状态或不同版本 */</span>
<span class="nc">.block__element--modifier</span> <span class="p">{}</span> <span class="c">/* 代表 .block__element 的不同状态或不同版本 */</span>
</code></pre></div></div>

<p>注意：</p>
<ol>
  <li>关于后代选择器，尽可能避免，例如 c-card button =&gt; c-card_button</li>
  <li>约定名称作为命名空间：组件 c-com，质量 qa-quality</li>
  <li>跨组件的情况可以用 modifier 解决，例如 c-card__c-button =&gt; c-button–modifier</li>
  <li>差异不大的组件可以用 modifier 解决，例如 visible-card, hidden-card =&gt; c-card–visible, c-card–hidden</li>
  <li>处理状态可以用独立的状态（如 is-active）或 modifier（如 c-button–active）</li>
  <li>class 数量过多时可以考虑 modifier，虽然比较长，但是表示明确，例如 card, card-black, card-visible =&gt; c-card–black c-card–visible</li>
</ol>

<p>参考：</p>
<blockquote>
  <p><a href="https://segmentfault.com/a/1190000000391762" title="BEM —— 源自Yandex的CSS 命名方法论">BEM —— 源自Yandex的CSS 命名方法论</a><br />
<a href="https://mp.weixin.qq.com/s?__biz=MzI3NTE2NjYxNw==&amp;mid=2650600379&amp;idx=1&amp;sn=a56047a4383616d2d218ecc89edb6af0&quot;">css命名管理混乱？不妨试试BEM</a><br />
<a href="https://www.w3cplus.com/css/battling-bem-extended-edition-common-problems-and-how-to-avoid-them.html">关于BEM中常见的十个问题以及如何避免</a></p>
</blockquote>
:ET