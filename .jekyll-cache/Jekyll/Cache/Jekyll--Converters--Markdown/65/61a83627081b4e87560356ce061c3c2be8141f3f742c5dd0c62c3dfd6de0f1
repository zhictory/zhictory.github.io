I"7<p>JavaScript 是单线程，不过 HTML5 提出新标准，允许 JavaScript 创建多个子线程，子线程还是受主线程控制。</p>

<p>由于主线程需要监听并多次调用子线程，就形成了 Event Loop。这么多个任务需要进入主线程，自然要排队执行，所以 JavaScript 除了主线程（负责同步任务），还需要一个任务队列（负责异步任务）。</p>

<h2 id="主线程和任务队列">主线程和任务队列</h2>

<p>我们先了解一下主线程和任务队列。</p>

<ul>
  <li>
    <p>主线程<br />
在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，这也称之为同步任务。</p>
  </li>
  <li>
    <p>任务队列<br />
进入任务队列的任务，不进入主线程，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行，这也称之为异步任务。</p>
  </li>
</ul>

<p>主线程和任务队列的示意图：</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100801.jpg" alt="" /></p>

<p>示意图分为两部分，左边主线程和右边任务队列，主线程负责渲染页面并监听任务队列，任务队列负责监听各种事件等候进入主线程。其中，任务队列可以放置异步任务事件和定时事件。</p>

<h2 id="event-loop">Event Loop</h2>

<p>接下来了解一下 Event Loop。</p>

<p>维基对 Event Loop 的定义是：</p>

<blockquote>
  <p>In computer science, the <strong>event loop</strong>, <strong>message dispatcher</strong>, <strong>message loop</strong>, <strong>message pump</strong>, or <strong>run loop</strong> is a programming construct that waits for and dispatches events or messages in a program.</p>
</blockquote>

<p>由此可见，Event Loop 是一种等待和分派事件的编程构造或程序消息，它在浏览器和 Nodejs 里的表现有所不同。</p>

<p>浏览器中的 Event Loop 示意图：</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt="" /></p>

<p>其中，任务队列包含两个定时事件：setTimeout 和 setInterval。</p>

<p>Nodejs 的 Event Loop 示意图：</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100803.png" alt="" /></p>

<p>下图显示 Event Loop 操作顺序：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre></div></div>

<p>其中，任务队列包含四个定时事件：setTimeout、setInterval、setImmediate 和 process.nextTick。</p>

<ol>
  <li>Event Loop 里有个 poll 阶段，Node 很多 API 都是基于事件订阅完成的，这些 API 的回调应该都在 poll 阶段完成。</li>
  <li>当 poll 阶段的回调执行完，setImmediate 具有最高优先级，只要 poll 队列为空，无论是否有 timers 达到下限时间，setImmediate 的回调都先执行。</li>
  <li>process.nextTick 可以理解成一个微任务。也就是说，它其实不属于 Event Loop 的一部分。不管在什么地方调用，他们都会在其所处的 Event Loop 最后，Event Loop 进入下一个循环的阶段前执行。</li>
</ol>

<p>下面看几个例子来理解 Event Loop：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">timeout</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">TIMEOUT FIRED</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 1, TIMEOUT FIRED, 2</span>
</code></pre></div></div>

<p>这个例子中：</p>
<ol>
  <li>执行宏任务代码：1 TIMEOUT FIRED（这两个顺序可能交换）</li>
  <li>遇到的新的宏任务代码并执行：2</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">timeout</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">TIMEOUT FIRED</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// 1, 2, TIMEOUT FIRED</span>
</code></pre></div></div>

<p>这个例子说明如果有多个 process.nextTick 语句（不管它们是否嵌套），将全部在当前”执行栈”执行：</p>
<ol>
  <li>先执行微任务代码：1</li>
  <li>遇到新的微任务代码并执行：2</li>
  <li>再执行剩下的宏任务代码：TIMEOUT FIRED</li>
</ol>

<p>再来看两个稍难的例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">timeout0</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">nextTick1</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">nextTick2</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
  <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">nextTick3</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">sync</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">timeout2</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// timeout0, sync, nextTick1, nextTick3, nextTick2, timeout2</span>
</code></pre></div></div>

<p>这个例子中：</p>

<ol>
  <li>没有全局代码，直接执行宏任务代码：timeout0 sync</li>
  <li>接着执行微任务代码：nextTick1 nextTick3</li>
  <li>遇到一个新的微任务并执行：nextTick2</li>
  <li>最后执行剩下的宏任务代码：timeout2</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>

<span class="c1">// 1, 4, 7, 5, 2, 3, 6</span>
</code></pre></div></div>

<p>这个例子中：</p>

<ol>
  <li>这个例子先执行全局代码：1 4 7</li>
  <li>然后执行微任务代码：5</li>
  <li>接着执行宏任务代码：2</li>
  <li>遇到一个新的微任务并执行：3</li>
  <li>最后执行剩下的宏任务代码：6</li>
</ol>

<p>参考：</p>

<blockquote>
  <p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈 Event Loop</a><br />
<a href="https://segmentfault.com/a/1190000013102056#articleHeader10">由 setTimeout 和 setImmediate 执行顺序的随机性窥探 Node 的事件循环机制</a><br />
<a href="https://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop, Timers, and process.nextTick()</a><br />
<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops">Event loops</a><br />
<a href="https://juejin.im/post/5b8f76675188255c7c653811">带你彻底弄懂 Event Loop</a></p>
</blockquote>
:ET