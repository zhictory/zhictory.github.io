---
title: ECMAScript 6 要点
---

ES6 被称为 ES2015 ，ES7 被称为 ES2016 。TC-39 小组将来所有的 ES 版本都会使用这个以年份为基础的命名系统。更频繁的发布意味着每个新的 ES 版本拥有的新特性会比 ES6 少得多。

## ES6（ES2015）

1. [块级绑定][1]：块级声明也就是让所声明的变量在指定块的作用域外无法被访问。
2. [字符串与正则][2]：ES6 的创造者加强了字符串与正则表达式，为它们添加了新的能力，并补充了一些长期缺失的功能。
3. [增强的数组功能][3]： ES6 也添加了很多功能来继续强化数组，例如新的创建方法、几个有用的便捷方法，还增加了创建类型化数组（typed array）的能力。
4. [扩展的对象功能][4]：随着 JS 应用复杂度的增长，在 JS 程序中所使用的对象的平均数也在持续增长，因此更有效使用对象就变得更加必要。
5. [函数][5]：ES6 之前的版本经常需要用大量代码来实现非常基本的功能。ES6 在 ES5 函数基础上实现了不少增量改进，让 JS 更加强大，同时编程错误也更少。
6. [解构赋值][6]：我们时常要定义对象与数组，然后有条不紊地从这些结构中提取出相关信息。为了简化提取信息的任务， ES6 新增了解构（ destructuring ），这是将一个数据结构分解为更小的部分的过程。
7. [Symbol][7]：在 Symbol 诞生之前，将字符串作为属性名称导致属性可以被轻易访问。而“私有名称”意味着开发者可以创建非字符串类型的属性名称，由此可以防止使用常规手段来探查这些名称。虽然 Symbol 类型的属性不是真正的私有属性，但它们难以被开发者无意修改，因此非常适用于需要提供一定层次保护的场合。
8. [Set 和 Map][8]：数组在 JS 中的使用正如其他语言的数组一样，但缺少更多类型的集合导致数组也经常被当作队列与栈来使用。数组只使用了数值型的索引，而若需要有非数值型的索引，开发者便会使用非数组的对象，用它们来定制实现 Set 与 Map，ES6 为 JS 添加了 Set 与 Map。
9. [Promise 与异步编程][9]：随着越来越多的程序开始使用异步编程，事件与回调函数已不足以支持开发者的所有需求。Promise 是异步编程的另一种选择，它的工作方式类似于在其他语言中进行延迟并在将来执行作业。
10. [迭代器与生成器][10]：许多编程语言都将迭代数据的方式从使用 for 循环转变到使用迭代器对象， for 循环需要初始化变量以便追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。
11. [类][11]：ES6 的类让 JS 中的继承变得更简单，起初是作为 ES5 传统继承模型的语法糖，但添加了许多特性来减少错误。
12. [代理和反射][12]：语言通过代理（ proxy ）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 JS 引擎的底层操作。代理允许你为一些 JS 底层操作自行定义非常规行为，因此你就可以通过代理陷阱来复制 JS 内置对象的所有行为。
13. [模块封装][13]：其他语言使用包（ package ）之类的概念来定义代码的作用域，然而在 ES6 之前，一个应用的每个 JS 文件所定义的所有内容都由全局作用域共享。当 web 应用变得更加复杂、需要使用越来越多的 JS 代码时，这种方式导致了诸多问题，例如命名冲突、安全问题等。 ES6 的设计目标之一就是要解决作用域问题，并让 JS 应用变得更有条理。
14. [处理整型][14]：JS 使用 IEEE 754 编码系统来表示整型与浮点型，多年以来这引发了很多混乱。 ES6 力图解决这方面的问题，让整型变得更易识别、更易处理，如识别整型、安全的整型。
15. [新的数学方法][14]：ES6 的游戏与图形的新重点引导它将类型化数组（ typed array ）引入了 JS ，同时也让它意识到 JS 引擎应当更有效率地进行许多数学计算。
16. [规范化 \__proto__][14]：使用 Object.getPrototypeOf() 和 Object.setPrototypeOf() 代替 \__proto__。

## ES2016

1. [幂运算符][15]：虽然已经有 Math.pow() 方法可用于幂运算，然而 JS 也是在此方面只能调用方法而不能使用运算符的少数语言之一，并且一些开发者认为运算符可读性更强、更易于检查。
1. [Array.prototype.includes()][15]：此方法的规范未能赶上 ES6 的最后期限，于是最终它就进入了 ES2016 。
1. [函数作用域的严格模式][15]：ES6 仍然允许你使用 "use strict" 指令来指定严格模式，可以在全局作用域上，让所有代码运行在严格模式下；或用在函数作用域内，只有该函数会运行在严格模式下。后一种方式最终在 ES6 中成为了一个问题，这是由于参数可以用更加复杂的方式来定义，特别是在带有解构或默认值的情况下。

参考：
> [《Understanding ECMAScript 6》中文翻译][20]

  [1]: https://mubu.com/doc/3c34Yt920U
  [2]: https://mubu.com/doc/3P8c0NrFsU
  [3]: https://mubu.com/doc/3P3E-kFZKU
  [4]: https://mubu.com/doc/1SO6-GmBBU
  [5]: https://mubu.com/doc/2ExlOG9xsU
  [6]: https://mubu.com/doc/11vwg2GpsU
  [7]: https://mubu.com/doc/3ErOLQGXBU
  [8]: https://mubu.com/doc/2P9c1cW7aU
  [9]: https://mubu.com/doc/I6GK9eZKU
  [10]: https://mubu.com/doc/2c44YUofaU
  [11]: https://mubu.com/doc/1ge6gHSCUU
  [12]: https://mubu.com/doc/2I0aGQKMLU
  [13]: https://mubu.com/doc/1LCQ741FTU
  [14]: https://mubu.com/doc/3AoD1dZpGU
  [15]: https://mubu.com/doc/3E550IxFGU
  [20]: https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/
